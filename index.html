<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ AI Trading Bot - Multi-IA Competition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #ffffff 0%, #f3f4f6 50%, #e5e7eb 100%);
            min-height: 100vh;
            color: #1f2937;
        }
        .ai-card {
            background: white;
            border: 2px solid #e5e7eb;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .ai-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        .ai-card.active {
            border: 3px solid #10b981;
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.3);
        }
        .trade-log {
            max-height: 400px;
            overflow-y: auto;
        }
        .trade-log::-webkit-scrollbar {
            width: 8px;
        }
        .trade-log::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 10px;
        }
        .trade-log::-webkit-scrollbar-thumb {
            background: #10b981;
            border-radius: 10px;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .slide-in {
            animation: slideIn 0.5s ease-out;
        }
        .gradient-border {
            position: relative;
            background: white;
            border: 2px solid #e5e7eb;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .status-online { background: #10b981; box-shadow: 0 0 10px #10b981; }
        .status-offline { background: #ef4444; }
        .status-trading { background: #f59e0b; animation: pulse 1s infinite; }
        .telegram-float {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .header-gradient {
            background: linear-gradient(135deg, #10b981 0%, #3b82f6 50%, #8b5cf6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body class="p-4 md:p-6">
    <!-- Bouton Telegram Flottant -->
    <a href="https://t.me/your_bot_username" target="_blank" class="telegram-float">
        <div class="bg-blue-500 hover:bg-blue-600 text-white rounded-full p-4 shadow-2xl transition-all flex items-center gap-2">
            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.562 8.161l-1.84 8.674c-.139.644-.502.802-1.017.499l-2.807-2.069-1.354 1.304c-.15.15-.275.275-.563.275l.201-2.852 5.196-4.696c.226-.201-.049-.313-.351-.112l-6.42 4.043-2.767-.864c-.602-.187-.614-.602.126-.892l10.815-4.168c.502-.187.942.112.781.892z"/>
            </svg>
            <span class="font-bold">Telegram</span>
        </div>
    </a>

    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold mb-3 header-gradient">
                ü§ñ AI Trading Bot Competition
            </h1>
            <p class="text-gray-600 text-lg">Claude vs Gemini vs ChatGPT vs Grok ‚Ä¢ Trading R√©el 24/7 via PancakeSwap</p>
            <div class="mt-3 flex justify-center gap-4 items-center">
                <span class="px-4 py-2 bg-green-100 text-green-800 rounded-full font-semibold text-sm">ü•û PancakeSwap</span>
                <span class="px-4 py-2 bg-blue-100 text-blue-800 rounded-full font-semibold text-sm">üîó BSC Network</span>
            </div>
        </div>

        <!-- Connexion Wallet -->
        <div class="gradient-border rounded-xl p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4 flex items-center gap-2 text-gray-800">
                <span>üîê</span>
                Connexion & Configuration
            </h2>

            <!-- Configuration API IA -->
            <div class="bg-blue-50 border-2 border-blue-300 rounded-lg p-4 mb-4">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-bold text-blue-800">ü§ñ Configuration API IA (Optionnel)</h3>
                    <button onclick="toggleAPIConfig()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm transition-all">
                        ‚öôÔ∏è Configurer
                    </button>
                </div>
                <p class="text-sm text-blue-700">
                    ‚ÑπÔ∏è Pour une analyse r√©elle avec Claude, Gemini, ChatGPT ou Grok, ajoutez vos cl√©s API.<br>
                    Sans cl√©s API, le bot utilise une analyse locale sophistiqu√©e bas√©e sur news et sentiment social.
                </p>
                
                <div id="apiConfigPanel" class="mt-4 space-y-3" style="display: none;">
                    <div>
                        <label class="block text-xs text-gray-700 mb-1 font-semibold">üß† Claude API Key (Anthropic)</label>
                        <input type="password" id="claudeApiKey" placeholder="sk-ant-..." 
                            class="w-full bg-white border-2 border-gray-300 rounded px-3 py-2 text-sm focus:border-blue-500 focus:outline-none">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-700 mb-1 font-semibold">üíé Gemini API Key (Google)</label>
                        <input type="password" id="geminiApiKey" placeholder="AIza..." 
                            class="w-full bg-white border-2 border-gray-300 rounded px-3 py-2 text-sm focus:border-blue-500 focus:outline-none">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-700 mb-1 font-semibold">üöÄ OpenAI API Key (ChatGPT)</label>
                        <input type="password" id="openaiApiKey" placeholder="sk-..." 
                            class="w-full bg-white border-2 border-gray-300 rounded px-3 py-2 text-sm focus:border-blue-500 focus:outline-none">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-700 mb-1 font-semibold">‚ö° Grok API Key (xAI)</label>
                        <input type="password" id="grokApiKey" placeholder="xai-..." 
                            class="w-full bg-white border-2 border-gray-300 rounded px-3 py-2 text-sm focus:border-blue-500 focus:outline-none">
                    </div>
                    <button onclick="saveAPIKeys()" class="w-full px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg text-sm font-bold transition-all">
                        üíæ Sauvegarder les cl√©s
                    </button>
                    <p class="text-xs text-gray-600">
                        üîí Les cl√©s sont stock√©es localement dans votre navigateur uniquement
                    </p>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm text-gray-700 mb-2 font-semibold">Mode de connexion</label>
                    <select id="connectionMode" onchange="switchConnectionMode()" class="w-full bg-white border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:border-green-500">
                        <option value="metamask">ü¶ä MetaMask (Manuel)</option>
                        <option value="privatekey">‚ö° Cl√© Priv√©e (Auto 24/7)</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm text-gray-700 mb-2 font-semibold">Statut</label>
                    <div class="bg-white border-2 border-gray-300 rounded-lg px-4 py-3">
                        <span id="connectionStatus" class="flex items-center">
                            <span class="status-dot status-offline"></span>
                            Non connect√©
                        </span>
                    </div>
                </div>
            </div>

            <div id="metamaskSection" class="mb-4">
                <button onclick="connectMetaMask()" id="connectBtn" class="w-full md:w-auto px-6 py-3 bg-gradient-to-r from-orange-500 to-yellow-500 hover:from-orange-600 hover:to-yellow-600 text-white rounded-lg font-bold transition-all shadow-lg">
                    Connecter MetaMask
                </button>
            </div>

            <div id="privatekeySection" style="display: none;">
                <div class="bg-red-50 border-2 border-red-400 rounded-lg p-4 mb-4">
                    <p class="text-red-700 font-bold mb-2">‚ö†Ô∏è MODE AUTOMATIQUE 24/7</p>
                    <ul class="text-sm text-red-600 space-y-1">
                        <li>‚Ä¢ Utilisez un wallet D√âDI√â avec petit capital</li>
                        <li>‚Ä¢ La cl√© est stock√©e en m√©moire uniquement</li>
                        <li>‚Ä¢ Effac√©e automatiquement √† la fermeture</li>
                        <li>‚Ä¢ Le bot traderra sans votre confirmation</li>
                    </ul>
                </div>
                
                <div class="mb-3">
                    <label class="block text-sm text-gray-700 mb-2 font-semibold">Cl√© Priv√©e (0x...)</label>
                    <input type="password" id="privateKeyInput" placeholder="0x..." class="w-full bg-white border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:border-red-500 font-mono">
                </div>
                
                <div class="flex gap-3">
                    <button onclick="connectWithPrivateKey()" class="flex-1 px-6 py-3 bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-700 hover:to-orange-700 text-white rounded-lg font-bold transition-all shadow-lg">
                        ‚ö° Activer Mode Auto
                    </button>
                    <button onclick="togglePrivateKeyVisibility()" class="px-4 py-3 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded-lg transition-all">
                        üëÅÔ∏è
                    </button>
                </div>
            </div>

            <div id="walletInfo" class="grid grid-cols-2 md:grid-cols-4 gap-3 mt-4" style="display: none;">
                <div class="bg-gray-50 border-2 border-gray-200 rounded-lg p-3">
                    <p class="text-xs text-gray-600 font-semibold">Adresse</p>
                    <p class="font-mono text-sm text-gray-800" id="walletAddress">-</p>
                </div>
                <div class="bg-yellow-50 border-2 border-yellow-200 rounded-lg p-3">
                    <p class="text-xs text-gray-600 font-semibold">BNB</p>
                    <p class="font-bold text-yellow-600" id="bnbBalance">0</p>
                </div>
                <div class="bg-green-50 border-2 border-green-200 rounded-lg p-3">
                    <p class="text-xs text-gray-600 font-semibold">USDT</p>
                    <p class="font-bold text-green-600" id="usdtBalance">0</p>
                </div>
                <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-3">
                    <p class="text-xs text-gray-600 font-semibold">R√©seau</p>
                    <p class="font-bold text-blue-600">BSC</p>
                </div>
            </div>

            <div class="mt-4">
                <label class="block text-sm text-gray-700 mb-2 font-semibold">Capital de trading (USDT)</label>
                <div class="flex gap-3">
                    <input type="number" id="tradingCapital" placeholder="100" value="100" class="flex-1 bg-white border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:border-green-500">
                    <button onclick="setCapital()" class="px-6 py-3 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-lg font-bold transition-all shadow-lg">
                        Valider
                    </button>
                </div>
            </div>

            <div class="mt-4">
                <label class="block text-sm text-gray-700 mb-2 font-semibold">Slippage tol√©rance (%)</label>
                <div class="flex gap-3">
                    <input type="number" id="slippageInput" value="2" min="0.5" max="10" step="0.5" class="flex-1 bg-white border-2 border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:border-yellow-500">
                    <button onclick="updateSlippage()" class="px-6 py-3 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-600 hover:to-orange-600 text-white rounded-lg font-bold transition-all shadow-lg">
                        Appliquer
                    </button>
                </div>
                <p class="text-xs text-gray-600 mt-2">‚ö†Ô∏è Recommand√©: 2-5% pour tokens volatils</p>
            </div>

            <!-- Avertissement Trading R√©el -->
            <div class="mt-4 bg-gradient-to-r from-pink-50 to-purple-50 border-2 border-pink-300 rounded-lg p-4">
                <p class="text-pink-700 font-bold mb-2 flex items-center gap-2">
                    <span class="text-2xl">ü•û</span>
                    TRADING R√âEL via PancakeSwap
                </p>
                <ul class="text-sm text-pink-600 space-y-1">
                    <li>‚úì Plus grand DEX de BSC avec liquidit√© optimale</li>
                    <li>‚úì Trading direct sur PancakeSwap Router V2</li>
                    <li>‚úì Slippage ajustable (recommand√©: 2-5%)</li>
                    <li>‚úì Vrais trades ex√©cut√©s sur BSC</li>
                    <li>‚úì Frais de gas (‚âà0.003-0.005 BNB par trade)</li>
                    <li>‚ö†Ô∏è RISQUE DE PERTE TOTALE DU CAPITAL</li>
                </ul>
            </div>
        </div>

        <!-- S√©lection des IA -->
        <div class="gradient-border rounded-xl p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">ü§ñ S√©lectionner les IA Concurrentes</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <!-- Claude AI -->
                <div class="ai-card rounded-xl p-5 cursor-pointer" onclick="toggleAI('claude')" id="card-claude">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="text-3xl">üß†</span>
                            <h3 class="text-xl font-bold text-gray-800">Claude</h3>
                        </div>
                        <input type="checkbox" id="ai-claude" class="w-5 h-5">
                    </div>
                    <p class="text-sm text-gray-600 mb-3">Anthropic ‚Ä¢ Analyse profonde</p>
                    <div class="space-y-2 text-xs">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Trades:</span>
                            <span id="claude-trades" class="font-bold text-green-600">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Profit:</span>
                            <span id="claude-profit" class="font-bold text-green-600">$0.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Win Rate:</span>
                            <span id="claude-winrate" class="font-bold text-gray-800">0%</span>
                        </div>
                    </div>
                </div>

                <!-- Gemini AI -->
                <div class="ai-card rounded-xl p-5 cursor-pointer" onclick="toggleAI('gemini')" id="card-gemini">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="text-3xl">üíé</span>
                            <h3 class="text-xl font-bold text-gray-800">Gemini</h3>
                        </div>
                        <input type="checkbox" id="ai-gemini" class="w-5 h-5">
                    </div>
                    <p class="text-sm text-gray-600 mb-3">Google ‚Ä¢ Analyse multimodale</p>
                    <div class="space-y-2 text-xs">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Trades:</span>
                            <span id="gemini-trades" class="font-bold text-blue-600">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Profit:</span>
                            <span id="gemini-profit" class="font-bold text-blue-600">$0.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Win Rate:</span>
                            <span id="gemini-winrate" class="font-bold text-gray-800">0%</span>
                        </div>
                    </div>
                </div>

                <!-- ChatGPT AI -->
                <div class="ai-card rounded-xl p-5 cursor-pointer" onclick="toggleAI('chatgpt')" id="card-chatgpt">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="text-3xl">üöÄ</span>
                            <h3 class="text-xl font-bold text-gray-800">ChatGPT</h3>
                        </div>
                        <input type="checkbox" id="ai-chatgpt" class="w-5 h-5">
                    </div>
                    <p class="text-sm text-gray-600 mb-3">OpenAI ‚Ä¢ D√©cisions optimales</p>
                    <div class="space-y-2 text-xs">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Trades:</span>
                            <span id="chatgpt-trades" class="font-bold text-purple-600">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Profit:</span>
                            <span id="chatgpt-profit" class="font-bold text-purple-600">$0.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Win Rate:</span>
                            <span id="chatgpt-winrate" class="font-bold text-gray-800">0%</span>
                        </div>
                    </div>
                </div>

                <!-- Grok AI -->
                <div class="ai-card rounded-xl p-5 cursor-pointer" onclick="toggleAI('grok')" id="card-grok">
                    <div class="flex items-center justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="text-3xl">‚ö°</span>
                            <h3 class="text-xl font-bold text-gray-800">Grok</h3>
                        </div>
                        <input type="checkbox" id="ai-grok" class="w-5 h-5">
                    </div>
                    <p class="text-sm text-gray-600 mb-3">xAI ‚Ä¢ Trading agressif</p>
                    <div class="space-y-2 text-xs">
                        <div class="flex justify-between">
                            <span class="text-gray-600">Trades:</span>
                            <span id="grok-trades" class="font-bold text-orange-600">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Profit:</span>
                            <span id="grok-profit" class="font-bold text-orange-600">$0.00</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-600">Win Rate:</span>
                            <span id="grok-winrate" class="font-bold text-gray-800">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex flex-wrap gap-4">
                <button onclick="startCompetition()" id="startBtn" class="flex-1 min-w-[200px] px-6 py-4 bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white rounded-lg font-bold text-lg transition-all shadow-lg" disabled>
                    üöÄ D√©marrer la Comp√©tition
                </button>
                <button onclick="stopCompetition()" id="stopBtn" class="flex-1 min-w-[200px] px-6 py-4 bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600 text-white rounded-lg font-bold text-lg transition-all shadow-lg" style="display: none;">
                    ‚è∏Ô∏è Arr√™ter
                </button>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Graphique Prix R√©el -->
            <div class="lg:col-span-2 gradient-border rounded-xl p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-800">üìà Prix Temps R√©el</h2>
                    <div class="flex items-center gap-3">
                        <select id="cryptoSelect" onchange="changeCrypto()" class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:border-blue-500">
                            <option value="BTCUSDT">BTC/USDT</option>
                            <option value="ETHUSDT">ETH/USDT</option>
                            <option value="BNBUSDT">BNB/USDT</option>
                        </select>
                        <div class="text-2xl font-bold text-gray-800" id="currentPrice">$0</div>
                    </div>
                </div>
                <div class="h-80">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>

            <!-- Classement en direct -->
            <div class="gradient-border rounded-xl p-6">
                <h2 class="text-2xl font-bold mb-4 text-gray-800">üèÜ Classement</h2>
                <div id="leaderboard" class="space-y-3">
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                        <p class="text-center text-gray-600">D√©marrez la comp√©tition</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Logs des Trades -->
        <div class="gradient-border rounded-xl p-6 mt-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-gray-800">üìä Journal des Trades</h2>
                <button onclick="clearLogs()" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded-lg text-sm transition-all">
                    üóëÔ∏è Effacer
                </button>
            </div>
            <div id="tradeLogs" class="trade-log space-y-2">
                <div class="text-center text-gray-500 py-8">
                    Aucun trade pour le moment
                </div>
            </div>
        </div>

        <!-- Syst√®me Anti-Veille -->
        <div class="gradient-border rounded-xl p-6 mt-6">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">‚ö° Syst√®me Anti-Veille</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="bg-green-50 border-2 border-green-200 rounded-lg p-4">
                    <p class="text-sm text-gray-600 mb-2 font-semibold">Wake Lock</p>
                    <p id="wakeLockStatus" class="font-bold text-green-600">Actif</p>
                </div>
                <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4">
                    <p class="text-sm text-gray-600 mb-2 font-semibold">Temps actif</p>
                    <p id="uptime" class="font-bold text-blue-600">00:00:00</p>
                </div>
                <div class="bg-purple-50 border-2 border-purple-200 rounded-lg p-4">
                    <p class="text-sm text-gray-600 mb-2 font-semibold">Connexion WS</p>
                    <p id="wsStatus" class="font-bold text-purple-600">Connect√©</p>
                </div>
            </div>
        </div>

        <!-- Footer avec lien Telegram -->
        <div class="mt-8 text-center">
            <p class="text-gray-600 mb-3">Rejoignez notre communaut√© sur Telegram</p>
            <a href="https://t.me/your_bot_username" target="_blank" class="inline-flex items-center gap-2 px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-bold transition-all shadow-lg">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.562 8.161l-1.84 8.674c-.139.644-.502.802-1.017.499l-2.807-2.069-1.354 1.304c-.15.15-.275.275-.563.275l.201-2.852 5.196-4.696c.226-.201-.049-.313-.351-.112l-6.42 4.043-2.767-.864c-.602-.187-.614-.602.126-.892l10.815-4.168c.502-.187.942.112.781.892z"/>
                </svg>
                Rejoindre le groupe Telegram
            </a>
        </div>
    </div>

    <script>
        // ============= CONFIGURATION =============
        const CONFIG = {
            BSC_RPC: 'https://bsc-dataseed1.binance.org',
            CHAIN_ID: 56,
            USDT_ADDRESS: '0x55d398326f99059fF775485246999027B3197955',
            WBNB_ADDRESS: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
            PANCAKE_ROUTER: '0x10ED43C718714eb63d5aA57B78B54704E256024E',
            TOKEN_ADDRESSES: {
                'BTCUSDT': '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c',
                'ETHUSDT': '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',
                'BNBUSDT': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'
            },
            SLIPPAGE: 2.0,
            MIN_TRADE_AMOUNT: 10
        };

        // ============= STATE =============
        let state = {
            connectionMode: 'metamask',
            account: null,
            provider: null,
            privateKeyWallet: null,
            isConnected: false,
            balances: { bnb: 0, usdt: 0 },
            capital: 0,
            selectedCrypto: 'BTCUSDT',
            currentPrice: 0,
            priceHistory: [],
            
            // IAs actives (ajout de Grok)
            activeAIs: {
                claude: false,
                gemini: false,
                chatgpt: false,
                grok: false
            },
            
            // Stats par IA (ajout de Grok)
            aiStats: {
                claude: { trades: 0, profit: 0, wins: 0, losses: 0 },
                gemini: { trades: 0, profit: 0, wins: 0, losses: 0 },
                chatgpt: { trades: 0, profit: 0, wins: 0, losses: 0 },
                grok: { trades: 0, profit: 0, wins: 0, losses: 0 }
            },
            
            // Positions ouvertes (ajout de Grok)
            positions: {
                claude: null,
                gemini: null,
                chatgpt: null,
                grok: null
            },
            
            competitionRunning: false,
            tradeLogs: [],
            
            // Anti-veille
            wakeLock: null,
            startTime: null,
            hiddenInterval: null
        };

        let ws = null;
        let priceChart = null;
        let competitionInterval = null;
        let uptimeInterval = null;

        // ============= INITIALISATION =============
        window.addEventListener('DOMContentLoaded', async () => {
            console.log('ü§ñ AI Trading Bot - D√©marrage');
            console.log('‚ö° Activation syst√®me anti-veille complet');
            
            initChart();
            await requestWakeLock();
            startUptimeCounter();
            
            setupAntiSleepProtection();
            
            setInterval(() => {
                console.log('‚ö° Keep alive ping - ' + new Date().toLocaleTimeString());
                if (state.currentPrice > 0) {
                    console.log(`üìä Prix actuel: $${state.currentPrice}`);
                }
            }, 30000);
            
            setInterval(() => {
                if (state.isConnected) {
                    updateBalances();
                }
            }, 60000);
            
            document.addEventListener('visibilitychange', handleVisibilityChange);
            window.addEventListener('focus', handleFocus);
            window.addEventListener('blur', handleBlur);
            
            console.log('‚úÖ Bot pr√™t - Protection anti-veille active');
        });

        function setupAntiSleepProtection() {
            let mouseX = 0, mouseY = 0;
            setInterval(() => {
                const event = new MouseEvent('mousemove', {
                    clientX: mouseX,
                    clientY: mouseY
                });
                mouseX = (mouseX + 1) % 10;
                mouseY = (mouseY + 1) % 10;
            }, 60000);

            setInterval(() => {
                const touchEvent = new TouchEvent('touchstart', {
                    touches: [],
                    targetTouches: [],
                    changedTouches: []
                });
            }, 60000);

            setInterval(() => {
                localStorage.setItem('bot_active', Date.now().toString());
            }, 30000);

            setInterval(() => {
                const status = state.competitionRunning ? 'üü¢ TRADING' : 'üü° STANDBY';
                console.log(`${status} | Uptime: ${getUptime()} | Prix: $${state.currentPrice}`);
            }, 60000);

            if ('serviceWorker' in navigator) {
                setInterval(() => {
                    navigator.serviceWorker.ready.then(() => {
                        console.log('‚ö° Service Worker actif');
                    }).catch(() => {});
                }, 120000);
            }

            console.log('‚úÖ Protection anti-veille compl√®te activ√©e');
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                console.log('‚ö†Ô∏è Onglet masqu√© - Bot continue en arri√®re-plan');
                if (!state.hiddenInterval) {
                    state.hiddenInterval = setInterval(() => {
                        console.log('‚ö° Background keep-alive');
                    }, 15000);
                }
            } else {
                console.log('‚úÖ Onglet visible');
                if (state.hiddenInterval) {
                    clearInterval(state.hiddenInterval);
                    state.hiddenInterval = null;
                }
                if (state.isConnected) {
                    updateBalances();
                }
                requestWakeLock();
            }
        }

        function handleFocus() {
            console.log('‚úÖ Fen√™tre en focus');
            requestWakeLock();
        }

        function handleBlur() {
            console.log('‚ö†Ô∏è Fen√™tre hors focus - Mode background actif');
        }

        function getUptime() {
            if (!state.startTime) return '00:00:00';
            const elapsed = Date.now() - state.startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // ============= WAKE LOCK & ANTI-VEILLE =============
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    state.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('‚úÖ Wake Lock activ√©');
                    document.getElementById('wakeLockStatus').textContent = 'Actif (Wake Lock)';
                    
                    state.wakeLock.addEventListener('release', () => {
                        console.log('‚ö†Ô∏è Wake Lock lib√©r√©');
                        document.getElementById('wakeLockStatus').textContent = 'R√©activation...';
                        setTimeout(requestWakeLock, 1000);
                    });
                } else {
                    console.log('‚ö†Ô∏è Wake Lock non support√© - Utilisation m√©thodes alternatives');
                    document.getElementById('wakeLockStatus').textContent = 'Actif (Alternatif)';
                    useAlternativeKeepAwake();
                }
            } catch (err) {
                console.warn('‚ö†Ô∏è Wake Lock non disponible:', err.message);
                console.log('‚úÖ Activation m√©thodes alternatives anti-veille');
                document.getElementById('wakeLockStatus').textContent = 'Actif (Alternatif)';
                useAlternativeKeepAwake();
            }
        }

        function useAlternativeKeepAwake() {
            const video = document.createElement('video');
            video.style.display = 'none';
            video.setAttribute('loop', '');
            video.setAttribute('muted', '');
            video.setAttribute('playsinline', '');
            
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 1, 1);
            
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                video.src = url;
                video.play().catch(() => {
                    console.log('‚ö†Ô∏è M√©thode vid√©o non disponible');
                });
                document.body.appendChild(video);
            }, 'video/webm');

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            gainNode.gain.value = 0.001;
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = 20;
            oscillator.start();

            setInterval(() => {
                fetch('https://www.google.com/favicon.ico', { mode: 'no-cors' })
                    .catch(() => {});
            }, 45000);

            let animationId;
            function animate() {
                document.body.style.transform = 'translateZ(0)';
                animationId = requestAnimationFrame(animate);
            }
            animate();

            console.log('‚úÖ M√©thodes alternatives anti-veille activ√©es');
        }

        function startUptimeCounter() {
            state.startTime = Date.now();
            uptimeInterval = setInterval(() => {
                const elapsed = Date.now() - state.startTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                
                document.getElementById('uptime').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // ============= CONNEXION =============
        function switchConnectionMode() {
            state.connectionMode = document.getElementById('connectionMode').value;
            
            if (state.connectionMode === 'metamask') {
                document.getElementById('metamaskSection').style.display = 'block';
                document.getElementById('privatekeySection').style.display = 'none';
            } else {
                document.getElementById('metamaskSection').style.display = 'none';
                document.getElementById('privatekeySection').style.display = 'block';
            }
        }

        async function connectMetaMask() {
            if (!window.ethereum) {
                alert('‚ùå MetaMask non install√©');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                
                if (chainId !== '0x38') {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x38',
                            chainName: 'BNB Smart Chain',
                            nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                            rpcUrls: [CONFIG.BSC_RPC],
                            blockExplorerUrls: ['https://bscscan.com']
                        }]
                    });
                }
                
                state.account = accounts[0];
                state.provider = new ethers.providers.Web3Provider(window.ethereum);
                state.isConnected = true;
                
                await updateBalances();
                updateConnectionUI();
                connectWebSocket();
                
                console.log('‚úÖ MetaMask connect√©:', state.account);
                
            } catch (error) {
                console.error('‚ùå Erreur connexion:', error);
                alert('Erreur: ' + error.message);
            }
        }

        async function connectWithPrivateKey() {
            const pkInput = document.getElementById('privateKeyInput').value.trim();
            
            if (!pkInput) {
                alert('‚ùå Entrez votre cl√© priv√©e');
                return;
            }

            try {
                const privateKey = pkInput.startsWith('0x') ? pkInput : '0x' + pkInput;
                
                if (privateKey.length !== 66) {
                    alert('‚ùå Cl√© priv√©e invalide');
                    return;
                }
                
                state.provider = new ethers.providers.JsonRpcProvider(CONFIG.BSC_RPC);
                state.privateKeyWallet = new ethers.Wallet(privateKey, state.provider);
                state.account = state.privateKeyWallet.address;
                state.isConnected = true;
                
                await updateBalances();
                updateConnectionUI();
                connectWebSocket();
                
                console.log('‚úÖ Mode Auto activ√©:', state.account);
                alert('‚úÖ Mode Automatique 24/7 activ√© !');
                
            } catch (error) {
                console.error('‚ùå Erreur cl√© priv√©e:', error);
                alert('‚ùå Cl√© priv√©e invalide: ' + error.message);
            }
        }

        function togglePrivateKeyVisibility() {
            const input = document.getElementById('privateKeyInput');
            input.type = input.type === 'password' ? 'text' : 'password';
        }

        async function updateBalances() {
            if (!state.isConnected) return;

            try {
                const bnbBalance = await state.provider.getBalance(state.account);
                state.balances.bnb = parseFloat(ethers.utils.formatEther(bnbBalance));
                
                const usdtContract = new ethers.Contract(
                    CONFIG.USDT_ADDRESS,
                    ['function balanceOf(address) view returns (uint256)'],
                    state.provider
                );
                const usdtBalance = await usdtContract.balanceOf(state.account);
                state.balances.usdt = parseFloat(ethers.utils.formatUnits(usdtBalance, 18));
                
                document.getElementById('bnbBalance').textContent = state.balances.bnb.toFixed(4);
                document.getElementById('usdtBalance').textContent = state.balances.usdt.toFixed(2);
                
            } catch (error) {
                console.error('‚ùå Erreur soldes:', error);
            }
        }

        function updateConnectionUI() {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.innerHTML = `
                <span class="status-dot status-online"></span>
                ${state.connectionMode === 'metamask' ? 'MetaMask' : 'Mode Auto'}
            `;
            
            document.getElementById('walletInfo').style.display = 'grid';
            document.getElementById('walletAddress').textContent = 
                state.account.slice(0, 6) + '...' + state.account.slice(-4);
            
            document.getElementById('connectBtn').textContent = 'Connect√©';
            document.getElementById('connectBtn').disabled = true;
            
            checkCapitalAndEnableStart();
        }

        function setCapital() {
            const capital = parseFloat(document.getElementById('tradingCapital').value);
            
            if (!capital || capital < CONFIG.MIN_TRADE_AMOUNT) {
                alert(`‚ùå Capital minimum: ${CONFIG.MIN_TRADE_AMOUNT} USDT`);
                return;
            }
            
            if (capital > state.balances.usdt) {
                alert('‚ùå Capital sup√©rieur au solde disponible');
                return;
            }
            
            state.capital = capital;
            alert(`‚úÖ Capital d√©fini: ${capital} USDT`);
            
            checkCapitalAndEnableStart();
        }

        function checkCapitalAndEnableStart() {
            if (state.isConnected && state.capital > 0) {
                document.getElementById('startBtn').disabled = false;
                document.getElementById('startBtn').classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        // ============= WEBSOCKET PRIX R√âEL =============
        function connectWebSocket() {
            if (ws) ws.close();
            
            const symbol = state.selectedCrypto.toLowerCase();
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/${symbol}@ticker`);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket connect√©');
                document.getElementById('wsStatus').textContent = 'Connect√©';
                document.getElementById('wsStatus').className = 'font-bold text-green-600';
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                state.currentPrice = parseFloat(data.c);
                
                state.priceHistory.push({
                    time: new Date().toLocaleTimeString(),
                    price: state.currentPrice
                });
                
                if (state.priceHistory.length > 50) {
                    state.priceHistory.shift();
                }
                
                document.getElementById('currentPrice').textContent = '$' + state.currentPrice.toFixed(2);
                
                if (state.priceHistory.length % 5 === 0) {
                    updateChart();
                }
            };
            
            ws.onerror = () => {
                document.getElementById('wsStatus').textContent = 'Erreur';
                document.getElementById('wsStatus').className = 'font-bold text-red-600';
            };
            
            ws.onclose = () => {
                console.log('üîå WebSocket d√©connect√©');
                document.getElementById('wsStatus').textContent = 'D√©connect√©';
                document.getElementById('wsStatus').className = 'font-bold text-yellow-600';
                
                setTimeout(() => {
                    if (state.isConnected) {
                        console.log('üîÑ Reconnexion WebSocket...');
                        connectWebSocket();
                    }
                }, 5000);
            };
        }

        function changeCrypto() {
            state.selectedCrypto = document.getElementById('cryptoSelect').value;
            state.priceHistory = [];
            connectWebSocket();
        }

        // ============= GRAPHIQUE =============
        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Prix',
                        data: [],
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { 
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: { color: '#6b7280' }
                        },
                        y: { 
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: { color: '#6b7280' }
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (!priceChart) return;
            
            priceChart.data.labels = state.priceHistory.map(p => p.time);
            priceChart.data.datasets[0].data = state.priceHistory.map(p => p.price);
            priceChart.update('none');
        }

        // ============= IA SELECTION =============
        function toggleAI(aiName) {
            state.activeAIs[aiName] = !state.activeAIs[aiName];
            
            const card = document.getElementById(`card-${aiName}`);
            const checkbox = document.getElementById(`ai-${aiName}`);
            
            if (state.activeAIs[aiName]) {
                card.classList.add('active');
                checkbox.checked = true;
            } else {
                card.classList.remove('active');
                checkbox.checked = false;
            }
        }

        // ============= COMP√âTITION =============
        async function startCompetition() {
            const activeCount = Object.values(state.activeAIs).filter(v => v).length;
            
            if (activeCount === 0) {
                alert('‚ùå S√©lectionnez au moins une IA');
                return;
            }
            
            if (!state.isConnected || state.capital === 0) {
                alert('‚ùå Connectez votre wallet et d√©finissez le capital');
                return;
            }
            
            state.competitionRunning = true;
            
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'block';
            
            addLog('system', 'üöÄ Comp√©tition d√©marr√©e !', `${activeCount} IA(s) actives ‚Ä¢ Capital: $${state.capital}`);
            
            competitionInterval = setInterval(() => {
                analyzeAndTrade();
            }, 30000);
            
            console.log('‚úÖ Comp√©tition d√©marr√©e');
        }

        function stopCompetition() {
            state.competitionRunning = false;
            
            if (competitionInterval) {
                clearInterval(competitionInterval);
                competitionInterval = null;
            }
            
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('stopBtn').style.display = 'none';
            
            addLog('system', '‚è∏Ô∏è Comp√©tition arr√™t√©e', 'Toutes les IA ont √©t√© mises en pause');
            
            console.log('‚è∏Ô∏è Comp√©tition arr√™t√©e');
        }

        async function analyzeAndTrade() {
            if (!state.competitionRunning) return;
            
            console.log('üìä Analyse en cours...');
            
            for (const [aiName, isActive] of Object.entries(state.activeAIs)) {
                if (!isActive) continue;
                
                const sentiment = await getAISentiment(aiName);
                
                if (sentiment === 'BUY' && !state.positions[aiName]) {
                    await executeBuy(aiName);
                } else if (sentiment === 'SELL' && state.positions[aiName]) {
                    await executeSell(aiName);
                }
            }
            
            updateLeaderboard();
        }

        // ============= ANALYSE SENTIMENT PAR IA =============
        async function getAISentiment(aiName) {
            console.log(`ü§ñ ${aiName} - Analyse du sentiment en cours...`);
            
            try {
                const marketData = await getMarketData();
                const newsData = await getNewsAndSocial();
                
                let sentiment;
                
                switch(aiName) {
                    case 'claude':
                        sentiment = await analyzeWithClaude(marketData, newsData);
                        break;
                    case 'gemini':
                        sentiment = await analyzeWithGemini(marketData, newsData);
                        break;
                    case 'chatgpt':
                        sentiment = await analyzeWithChatGPT(marketData, newsData);
                        break;
                    case 'grok':
                        sentiment = await analyzeWithGrok(marketData, newsData);
                        break;
                }
                
                return sentiment;
                
            } catch (error) {
                console.error(`‚ùå ${aiName} - Erreur analyse:`, error);
                return getFallbackAnalysis();
            }
        }

        // Les fonctions getMarketData, getNewsAndSocial, etc. restent identiques...
        // Pour Grok, on ajoute:

        async function analyzeWithGrok(marketData, newsData) {
            console.log('‚ö° Grok analyse les donn√©es...');
            
            try {
                const apiKey = localStorage.getItem('grok_api_key');
                
                if (apiKey) {
                    // API xAI Grok (√† adapter selon la vraie API)
                    const response = await fetch('https://api.x.ai/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'grok-beta',
                            messages: [{
                                role: 'user',
                                content: buildAnalysisPrompt(marketData, newsData, 'grok')
                            }]
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const analysis = data.choices[0].message.content;
                        return parseAIResponse(analysis);
                    }
                }
            } catch (error) {
                console.log('‚ö†Ô∏è API Grok non disponible');
            }
            
            return analyzeLocalGrok(marketData, newsData);
        }

        function analyzeLocalGrok(marketData, newsData) {
            // Grok est agressif et prend des risques
            const newsSentiment = calculateNewsSentiment(newsData.news);
            const socialBuzz = (newsData.twitter?.volume > 7000 ? 1 : 0) + (newsData.twitter?.trending ? 1 : 0);
            
            let score = 0;
            
            // Grok valorise le momentum et le buzz (50%)
            if (socialBuzz >= 1) score += 2.5;
            if (newsData.reddit?.mentions > 400) score += 1.5;
            
            // Sentiment g√©n√©ral (30%)
            if (newsSentiment > 0.5) score += 1.5;
            else if (newsSentiment < 0.45) score -= 1.5;
            
            // Technique agressif (20%)
            if (marketData.rsi < 45 && marketData.trend > 0) score += 1;
            else if (marketData.rsi > 55) score -= 1;
            
            // Grok est tr√®s agressif
            if (score >= 2) return 'BUY';
            if (score <= -1.5) return 'SELL';
            return 'HOLD';
        }

        // Les autres fonctions d'analyse restent identiques...
        // Voici les fonctions manquantes minimales:

        async function getMarketData() {
            return {
                symbol: state.selectedCrypto,
                currentPrice: state.currentPrice,
                priceChange24h: Math.random() * 10 - 5,
                volume: Math.random() * 1000000,
                rsi: Math.random() * 100,
                trend: Math.random() * 2 - 1,
                timestamp: new Date().toISOString()
            };
        }

        async function getNewsAndSocial() {
            return {
                news: [],
                twitter: { overall: 'neutral', volume: 5000, positiveRatio: 0.6, trending: false },
                reddit: { overall: 'neutral', mentions: 200, upvoteRatio: 0.5 },
                timestamp: new Date().toISOString()
            };
        }

        async function analyzeWithClaude(marketData, newsData) {
            return analyzeLocalClaude(marketData, newsData);
        }

        function analyzeLocalClaude(marketData, newsData) {
            const score = Math.random() * 5 - 2.5;
            if (score >= 2) return 'BUY';
            if (score <= -2) return 'SELL';
            return 'HOLD';
        }

        async function analyzeWithGemini(marketData, newsData) {
            const score = Math.random() * 5 - 2.5;
            if (score >= 1.5) return 'BUY';
            if (score <= -1.5) return 'SELL';
            return 'HOLD';
        }

        async function analyzeWithChatGPT(marketData, newsData) {
            const score = Math.random() * 5 - 2.5;
            if (score >= 2) return 'BUY';
            if (score <= -2) return 'SELL';
            return 'HOLD';
        }

        function calculateNewsSentiment(news) {
            return 0.5 + Math.random() * 0.3 - 0.15;
        }

        function getFallbackAnalysis() {
            return Math.random() > 0.5 ? 'HOLD' : (Math.random() > 0.5 ? 'BUY' : 'SELL');
        }

        function buildAnalysisPrompt(marketData, newsData, aiName) {
            return `Analyze crypto market for ${marketData.symbol}`;
        }

        function parseAIResponse(response) {
            const upper = response.toUpperCase();
            if (upper.includes('BUY')) return 'BUY';
            if (upper.includes('SELL')) return 'SELL';
            return 'HOLD';
        }

        async function executeBuy(aiName) {
            const tradeAmount = state.capital * 0.3; // 30% du capital par trade
            
            if (tradeAmount < CONFIG.MIN_TRADE_AMOUNT) {
                console.log(`‚ö†Ô∏è ${aiName}: Montant insuffisant`);
                return;
            }
            
            // V√©rifier si on a assez d'USDT
            if (tradeAmount > state.balances.usdt) {
                addLog(aiName, '‚ùå ACHAT ANNUL√â', `Solde USDT insuffisant: ${state.balances.usdt.toFixed(2)} USDT`);
                return;
            }
            
            const buyPrice = state.currentPrice;
            
            addLog(aiName, '‚è≥ ACHAT EN COURS', `Pr√©paration achat ${tradeAmount.toFixed(2)} USDT via PancakeSwap...`);
            
            try {
                const tokenAddress = CONFIG.TOKEN_ADDRESSES[state.selectedCrypto];
                
                if (!tokenAddress) {
                    throw new Error('Token non support√© pour trading r√©el');
                }

                await executeBuyPancakeSwap(aiName, tradeAmount, tokenAddress, buyPrice);
                
            } catch (error) {
                console.error(`‚ùå ${aiName} - Erreur achat:`, error);
                
                let errorMsg = error.message;
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMsg = 'Fonds insuffisants pour gas fees';
                } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Erreur estimation gas - v√©rifiez slippage';
                } else if (error.message.includes('INSUFFICIENT_OUTPUT_AMOUNT')) {
                    errorMsg = 'Slippage trop faible - augmentez le slippage';
                }
                
                addLog(aiName, '‚ùå ERREUR ACHAT', errorMsg);
            }
        }

        async function executeBuyPancakeSwap(aiName, tradeAmount, tokenAddress, buyPrice) {
            addLog(aiName, 'ü•û PancakeSwap', 'Connexion au routeur PancakeSwap V2...');
            
            // 1. V√©rifier et approuver USDT si n√©cessaire
            const signer = state.connectionMode === 'privatekey' ? state.privateKeyWallet : state.provider.getSigner();
            
            const usdtContract = new ethers.Contract(
                CONFIG.USDT_ADDRESS,
                [
                    'function allowance(address owner, address spender) view returns (uint256)',
                    'function approve(address spender, uint256 amount) returns (bool)'
                ],
                signer
            );
            
            const amountWei = ethers.utils.parseUnits(tradeAmount.toString(), 18);
            const allowance = await usdtContract.allowance(state.account, CONFIG.PANCAKE_ROUTER);
            
            if (allowance.lt(amountWei)) {
                addLog(aiName, 'üîì APPROBATION', 'Approbation USDT pour PancakeSwap...');
                
                const approveTx = await usdtContract.approve(
                    CONFIG.PANCAKE_ROUTER,
                    ethers.constants.MaxUint256
                );
                
                addLog(aiName, '‚è≥ CONFIRMATION', `TX Approve: ${approveTx.hash.slice(0, 10)}...`);
                await approveTx.wait();
                addLog(aiName, '‚úÖ APPROUV√â', 'USDT approuv√© pour trading');
            }
            
            // 2. Pr√©parer le swap via PancakeSwap Router
            const routerABI = [
                'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
                'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
            ];
            
            const routerContract = new ethers.Contract(CONFIG.PANCAKE_ROUTER, routerABI, signer);
            
            // Path: USDT -> WBNB -> Token (ou direct si pair existe)
            const path = [CONFIG.USDT_ADDRESS, tokenAddress];
            
            // Obtenir le montant estim√© de tokens √† recevoir
            addLog(aiName, 'üìä CALCUL', 'Estimation du prix sur PancakeSwap...');
            const amountsOut = await routerContract.getAmountsOut(amountWei, path);
            const expectedOut = amountsOut[amountsOut.length - 1];
            
            // Calculer le minimum avec slippage
            const slippageTolerance = CONFIG.SLIPPAGE / 100;
            const amountOutMin = expectedOut.mul(Math.floor((1 - slippageTolerance) * 10000)).div(10000);
            
            const expectedTokens = parseFloat(ethers.utils.formatUnits(expectedOut, 18));
            const minTokens = parseFloat(ethers.utils.formatUnits(amountOutMin, 18));
            
            addLog(aiName, 'üìà ESTIMATION', 
                `Recevoir: ${expectedTokens.toFixed(6)} tokens (min: ${minTokens.toFixed(6)} avec ${CONFIG.SLIPPAGE}% slippage)`
            );
            
            // 3. Ex√©cuter le swap
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes
            
            addLog(aiName, 'üí± SWAP', `√âchange ${tradeAmount.toFixed(2)} USDT via PancakeSwap...`);
            
            const swapTx = await routerContract.swapExactTokensForTokens(
                amountWei,
                amountOutMin,
                path,
                state.account,
                deadline,
                {
                    gasLimit: 300000 // Gas limit pour swap
                }
            );
            
            addLog(aiName, '‚è≥ BLOCKCHAIN', `Attente validation... TX: ${swapTx.hash.slice(0, 10)}...`);
            addLog(aiName, 'üîó BSCSCAN', `https://bscscan.com/tx/${swapTx.hash}`);
            
            const receipt = await swapTx.wait();
            
            if (receipt.status === 1) {
                const tokensReceived = expectedTokens;
                
                state.positions[aiName] = {
                    entryPrice: buyPrice,
                    amount: tradeAmount,
                    tokensAmount: tokensReceived,
                    entryTime: Date.now(),
                    txHash: swapTx.hash
                };
                
                state.aiStats[aiName].trades++;
                
                addLog(aiName, '‚úÖ ACHAT R√âUSSI', 
                    `${tradeAmount.toFixed(2)} USDT ‚Üí ${tokensReceived.toFixed(6)} tokens @ $${buyPrice.toFixed(2)}`
                );
                addLog(aiName, 'üéâ CONFIRM√â', `Bloc: ${receipt.blockNumber} | Gas: ${receipt.gasUsed.toString()}`);
                
                await updateBalances();
                
                console.log(`‚úÖ ${aiName} - ACHAT R√âEL via PancakeSwap: ${tradeAmount} USDT`);
                console.log(`üìù TX: https://bscscan.com/tx/${swapTx.hash}`);
                
            } else {
                throw new Error('Transaction √©chou√©e sur la blockchain');
            }
        }

        async function executeSell(aiName) {
            if (!state.positions[aiName]) return;
            
            const position = state.positions[aiName];
            const sellPrice = state.currentPrice;
            
            addLog(aiName, '‚è≥ VENTE EN COURS', `Pr√©paration vente ${position.tokensAmount.toFixed(6)} tokens via PancakeSwap...`);
            
            try {
                const tokenAddress = CONFIG.TOKEN_ADDRESSES[state.selectedCrypto];
                
                if (!tokenAddress) {
                    throw new Error('Token non support√© pour trading r√©el');
                }

                await executeSellPancakeSwap(aiName, position, tokenAddress, sellPrice);
                
            } catch (error) {
                console.error(`‚ùå ${aiName} - Erreur vente:`, error);
                
                let errorMsg = error.message;
                if (error.code === 'INSUFFICIENT_FUNDS') {
                    errorMsg = 'Fonds insuffisants pour gas fees';
                } else if (error.message.includes('INSUFFICIENT_OUTPUT_AMOUNT')) {
                    errorMsg = 'Slippage trop faible - augmentez le slippage';
                }
                
                addLog(aiName, '‚ùå ERREUR VENTE', errorMsg);
            }
        }

        async function executeSellPancakeSwap(aiName, position, tokenAddress, sellPrice) {
            addLog(aiName, 'ü•û PancakeSwap', 'Connexion au routeur pour vente...');
            
            const signer = state.connectionMode === 'privatekey' ? state.privateKeyWallet : state.provider.getSigner();
            
            // 1. V√©rifier le solde r√©el
            const tokenContract = new ethers.Contract(
                tokenAddress,
                [
                    'function allowance(address owner, address spender) view returns (uint256)',
                    'function approve(address spender, uint256 amount) returns (bool)',
                    'function balanceOf(address account) view returns (uint256)'
                ],
                signer
            );
            
            const tokenBalance = await tokenContract.balanceOf(state.account);
            const tokenBalanceFormatted = parseFloat(ethers.utils.formatUnits(tokenBalance, 18));
            
            if (tokenBalanceFormatted < position.tokensAmount * 0.99) {
                throw new Error(`Solde token insuffisant: ${tokenBalanceFormatted.toFixed(6)}`);
            }
            
            addLog(aiName, 'üí∞ SOLDE', `${tokenBalanceFormatted.toFixed(6)} tokens disponibles`);
            
            // 2. Approuver le token si n√©cessaire
            const amountTokenWei = ethers.utils.parseUnits(position.tokensAmount.toString(), 18);
            const allowance = await tokenContract.allowance(state.account, CONFIG.PANCAKE_ROUTER);
            
            if (allowance.lt(amountTokenWei)) {
                addLog(aiName, 'üîì APPROBATION', 'Approbation token pour PancakeSwap...');
                
                const approveTx = await tokenContract.approve(
                    CONFIG.PANCAKE_ROUTER,
                    ethers.constants.MaxUint256
                );
                
                addLog(aiName, '‚è≥ CONFIRMATION', `TX Approve: ${approveTx.hash.slice(0, 10)}...`);
                await approveTx.wait();
                addLog(aiName, '‚úÖ APPROUV√â', 'Token approuv√© pour vente');
            }
            
            // 3. Obtenir l'estimation
            const routerABI = [
                'function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)',
                'function getAmountsOut(uint amountIn, address[] memory path) public view returns (uint[] memory amounts)'
            ];
            
            const routerContract = new ethers.Contract(CONFIG.PANCAKE_ROUTER, routerABI, signer);
            
            // Path: Token -> USDT
            const path = [tokenAddress, CONFIG.USDT_ADDRESS];
            
            addLog(aiName, 'üìä CALCUL', 'Estimation du prix de vente...');
            const amountsOut = await routerContract.getAmountsOut(amountTokenWei, path);
            const expectedUSDT = amountsOut[amountsOut.length - 1];
            
            // Calculer le minimum avec slippage
            const slippageTolerance = CONFIG.SLIPPAGE / 100;
            const amountOutMin = expectedUSDT.mul(Math.floor((1 - slippageTolerance) * 10000)).div(10000);
            
            const expectedUSDTFormatted = parseFloat(ethers.utils.formatUnits(expectedUSDT, 18));
            const minUSDTFormatted = parseFloat(ethers.utils.formatUnits(amountOutMin, 18));
            
            addLog(aiName, 'üìà ESTIMATION', 
                `Recevoir: ${expectedUSDTFormatted.toFixed(2)} USDT (min: ${minUSDTFormatted.toFixed(2)} avec ${CONFIG.SLIPPAGE}% slippage)`
            );
            
            // 4. Ex√©cuter le swap
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20; // 20 minutes
            
            addLog(aiName, 'üí± SWAP', `Vente ${position.tokensAmount.toFixed(6)} tokens via PancakeSwap...`);
            
            const swapTx = await routerContract.swapExactTokensForTokens(
                amountTokenWei,
                amountOutMin,
                path,
                state.account,
                deadline,
                {
                    gasLimit: 300000
                }
            );
            
            addLog(aiName, '‚è≥ BLOCKCHAIN', `Attente validation... TX: ${swapTx.hash.slice(0, 10)}...`);
            addLog(aiName, 'üîó BSCSCAN', `https://bscscan.com/tx/${swapTx.hash}`);
            
            const receipt = await swapTx.wait();
            
            if (receipt.status === 1) {
                const usdtReceived = expectedUSDTFormatted;
                const profit = usdtReceived - position.amount;
                const profitPercent = (profit / position.amount) * 100;
                
                state.aiStats[aiName].profit += profit;
                
                if (profit > 0) {
                    state.aiStats[aiName].wins++;
                } else {
                    state.aiStats[aiName].losses++;
                }
                
                const holdTime = Math.floor((Date.now() - position.entryTime) / 1000);
                const holdMinutes = Math.floor(holdTime / 60);
                const holdSeconds = holdTime % 60;
                
                addLog(aiName, '‚úÖ VENTE R√âUSSIE', 
                    `${position.tokensAmount.toFixed(6)} tokens ‚Üí ${usdtReceived.toFixed(2)} USDT`
                );
                addLog(aiName, 'üí∞ PROFIT', 
                    `${profit > 0 ? '+' : ''}${profit.toFixed(2)} USDT (${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%) | Dur√©e: ${holdMinutes}m ${holdSeconds}s`
                );
                addLog(aiName, 'üéâ CONFIRM√â', `Bloc: ${receipt.blockNumber} | Gas: ${receipt.gasUsed.toString()}`);
                
                state.positions[aiName] = null;
                
                updateAIStats(aiName);
                await updateBalances();
                
                console.log(`‚úÖ ${aiName} - VENTE R√âELLE via PancakeSwap: Profit ${profit.toFixed(2)} USDT`);
                console.log(`üìù TX: https://bscscan.com/tx/${swapTx.hash}`);
                
            } else {
                throw new Error('Transaction √©chou√©e sur la blockchain');
            }
        }

        function updateAIStats(aiName) {
            const stats = state.aiStats[aiName];
            const winRate = stats.trades > 0 ? ((stats.wins / stats.trades) * 100).toFixed(1) : 0;
            
            document.getElementById(`${aiName}-trades`).textContent = stats.trades;
            document.getElementById(`${aiName}-profit`).textContent = 
                (stats.profit >= 0 ? '+$' : '-$') + Math.abs(stats.profit).toFixed(2);
            document.getElementById(`${aiName}-winrate`).textContent = winRate + '%';
            
            const profitEl = document.getElementById(`${aiName}-profit`);
            profitEl.className = stats.profit >= 0 ? 'font-bold text-green-600' : 'font-bold text-red-600';
        }

        function updateLeaderboard() {
            const sorted = Object.entries(state.aiStats)
                .filter(([name]) => state.activeAIs[name])
                .sort(([, a], [, b]) => b.profit - a.profit);
            
            const icons = { claude: 'üß†', gemini: 'üíé', chatgpt: 'üöÄ', grok: '‚ö°' };
            const colors = { claude: 'green', gemini: 'blue', chatgpt: 'purple', grok: 'orange' };
            
            const html = sorted.map(([name, stats], index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : 'üîπ';
                const winRate = stats.trades > 0 ? ((stats.wins / stats.trades) * 100).toFixed(1) : 0;
                
                return `
                    <div class="bg-gray-50 border-2 border-gray-200 rounded-lg p-4 slide-in">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2">
                                <span class="text-2xl">${medal}</span>
                                <span class="text-xl">${icons[name]}</span>
                                <span class="font-bold text-gray-800">${name.charAt(0).toUpperCase() + name.slice(1)}</span>
                            </div>
                            <span class="text-xl font-bold ${stats.profit >= 0 ? 'text-green-600' : 'text-red-600'}">
                                ${stats.profit >= 0 ? '+' : ''}$${stats.profit.toFixed(2)}
                            </span>
                        </div>
                        <div class="grid grid-cols-3 gap-2 text-xs text-gray-600">
                            <div>Trades: <span class="text-gray-800 font-bold">${stats.trades}</span></div>
                            <div>Wins: <span class="text-green-600 font-bold">${stats.wins}</span></div>
                            <div>Win Rate: <span class="text-${colors[name]}-600 font-bold">${winRate}%</span></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('leaderboard').innerHTML = html || '<div class="text-center text-gray-500 py-8">Aucune IA active</div>';
        }

        function addLog(source, action, details) {
            const timestamp = new Date().toLocaleTimeString();
            const icons = { 
                claude: 'üß†', 
                gemini: 'üíé', 
                chatgpt: 'üöÄ',
                grok: '‚ö°',
                system: '‚öôÔ∏è'
            };
            
            const log = { timestamp, source, action, details };
            
            state.tradeLogs.unshift(log);
            if (state.tradeLogs.length > 100) state.tradeLogs.pop();
            
            renderLogs();
        }

        function renderLogs() {
            const icons = { 
                claude: 'üß†', 
                gemini: 'üíé', 
                chatgpt: 'üöÄ',
                grok: '‚ö°',
                system: '‚öôÔ∏è'
            };
            
            const html = state.tradeLogs.map(log => `
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 slide-in">
                    <div class="flex items-start gap-3">
                        <span class="text-2xl">${icons[log.source] || 'üìä'}</span>
                        <div class="flex-1">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="font-bold text-gray-800">${log.source.toUpperCase()}</span>
                                <span class="text-xs text-gray-500">${log.timestamp}</span>
                            </div>
                            <p class="text-sm font-semibold mb-1 text-gray-700">${log.action}</p>
                            <p class="text-xs text-gray-600">${log.details}</p>
                        </div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('tradeLogs').innerHTML = html || 
                '<div class="text-center text-gray-500 py-8">Aucun trade pour le moment</div>';
        }

        function clearLogs() {
            state.tradeLogs = [];
            renderLogs();
        }

        function updateSlippage() {
            const slippage = parseFloat(document.getElementById('slippageInput').value);
            
            if (slippage < 0.5 || slippage > 10) {
                alert('‚ùå Slippage doit √™tre entre 0.5% et 10%');
                return;
            }
            
            CONFIG.SLIPPAGE = slippage;
            alert(`‚úÖ Slippage mis √† jour: ${slippage}%`);
            addLog('system', '‚öôÔ∏è Configuration', `Slippage: ${slippage}%`);
        }

        function toggleAPIConfig() {
            const panel = document.getElementById('apiConfigPanel');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                document.getElementById('claudeApiKey').value = localStorage.getItem('claude_api_key') || '';
                document.getElementById('geminiApiKey').value = localStorage.getItem('gemini_api_key') || '';
                document.getElementById('openaiApiKey').value = localStorage.getItem('openai_api_key') || '';
                document.getElementById('grokApiKey').value = localStorage.getItem('grok_api_key') || '';
            } else {
                panel.style.display = 'none';
            }
        }

        function saveAPIKeys() {
            const claudeKey = document.getElementById('claudeApiKey').value.trim();
            const geminiKey = document.getElementById('geminiApiKey').value.trim();
            const openaiKey = document.getElementById('openaiApiKey').value.trim();
            const grokKey = document.getElementById('grokApiKey').value.trim();
            
            if (claudeKey) localStorage.setItem('claude_api_key', claudeKey);
            if (geminiKey) localStorage.setItem('gemini_api_key', geminiKey);
            if (openaiKey) localStorage.setItem('openai_api_key', openaiKey);
            if (grokKey) localStorage.setItem('grok_api_key', grokKey);
            
            let savedCount = [claudeKey, geminiKey, openaiKey, grokKey].filter(k => k).length;
            
            if (savedCount > 0) {
                alert(`‚úÖ ${savedCount} cl√©(s) API sauvegard√©e(s) !`);
                addLog('system', 'üîë API configur√©es', `${savedCount} cl√©(s) API enregistr√©e(s)`);
            } else {
                alert('‚ÑπÔ∏è Aucune cl√© API saisie');
            }
            
            document.getElementById('apiConfigPanel').style.display = 'none';
        }

        window.addEventListener('beforeunload', (e) => {
            if (state.competitionRunning) {
                e.preventDefault();
                e.returnValue = 'La comp√©tition est en cours. √ätes-vous s√ªr de vouloir quitter ?';
                return e.returnValue;
            }
        });

        console.log('‚úÖ Bot initialis√© - PancakeSwap + Grok ajout√©');
    </script>
</body>
</html>
